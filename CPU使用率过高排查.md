# CPU使用率

linux是用CPU时间片模拟多任务的，那么CPU的时间片单位要有，那么就是HZ，并有时间变量Jiffies记录开机的节拍数，可以通过/boot/config查看配置值

通过cat /proc/stat|grep ^cpu 可以查看CPU状态

```shell
root@iZm5e78t3hp8rw0t2g09ikZ:~# cat /proc/stat|grep ^cpu
cpu  11148039 0 10206602 1705048006 232966 0 8163 0 0 0
cpu0 11148039 0 10206602 1705048006 232966 0 8163 0 0 0
```

第一行是总和，我的阿里云实例只有1个cpu，所以第一行和第二行相等

各项参数是指各个状态的时间，如内核态cpu时间，空闲时间，硬中断时间等，这里不一一列举了，知道有这么一回事，等用到的时候，进行man proc即可

CPU使用率 = 1 - （空闲时间/总CPU时间）

那么3秒内的平均CPU使用率则为

CPU平均使用率 = 1 - （某3秒内空闲时间/某3秒内总CPU时间）

## top，ps，pidstat

top的默认取值是3秒，top没有区分用户态与内核态

ps默认的是整个程序的周期

pidstat展示了进程的具体用户态信息

# CPU使用率过高怎么办

1.第一时间分析进程的CPU问题的是perf，其能显示占用CPU时钟最多的函数和指令，因此能查找热点函数

2.GDB适合于性能分析后期，找到具体函数后，进一步调试

例子：ngnix请求数过低

1.查找问题，使用top，pidstat观察系统情况，默认此时是CPU问题，因为此篇章是关于CPU的分析的

2.通过pidstat找到是哪个进程CPU过载了

3.通过perf top -g -p ".......进程号"，发现其调用关系，得出哪个函数有问题

4.查看代码，改bug

5.修改bug，并重新上线，同样观察执行情况，验证解决情况



# 找不到对应的CPU高应用

现象：

1.通过top发现性能问题，cpu过载，但此时top下面的程序没有显示对应的程序

2.直接用pidstat，也没有发现占用cpu高的程序

**** 分析：

这种导致了CPU的爆增的原因却找不到程序的原因就常见的两种

1.exec短时任务

2.程序不断被监控程序重启

没有pid说明pid不复存在，而因为该pid时间过短，所以长时间间隔的top没有显示这个消失的pid，top将其忽略了，此时要找到处于R状态的进程，这些进程很可能是有问题的程序。通过pstree|grep '...处于R的进程'找到问题程序的父程序，通过pref record -g 记录该父进程调用情况，并运行perf record 查看输出，进一步明确其原因。如果发现确实有问题，就进行源码查看，找到其代码是否有问题。如果没有问题，此时查看是否是权限，依赖等外部因素导致的程序调用失败。

**** 更好工具：execsnoop

通过execsnoop直接发现短时任务的父进程





