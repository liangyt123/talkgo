# 内存映射
每个进程一个虚拟内存空间，是连续的。如虚拟内存空间有大小32位最多4GB。
虚拟内存通过页表（MMU）映射到物理内存,页面访问不到就缺页异常，去内核空间，更新进程页表，返回用户空间，恢复进程运行。TLB是MMU的高速缓存，访问速度高，上下文切换会刷新TLB，使访问变慢。
linux用多级页表进行缩小页表的范围
## 虚拟内存用户空间
用户态访问
## 虚拟内存内核空间
内核态访问,32为1GB
# 内存分布
内核空间->栈->文件映射->堆<-数据段<-只读段
1.只读段：代码，常量
2.数据段：全局变量
3.堆：动态分配的内存 从低地址开始增长(动态分配，malloc,mmap)
4.文件映射段：动态库，共享内存，从高往低增长(动态分配，malloc,mmap)
5.栈：局部变量，函数调用的上下文，固定大小，一般为8kb

# 动态内存分配回收
## 内存分配
malloc是c语言实现，系统调用是brk(),mmap()
**** 小于128k 用brk,移动堆顶
**** 大于128k 用mmap，在文件映射段找空闲内存分配
brk：频繁分配，内存没有回收会造成碎片
mmap：马上回收，所以每次mmap都会缺页异常

两种调用后，并么有真正分配内存，只有首次访问才分配，也就是通过缺页异常进入内核，再由内核分配

分配以页为单位，页大小4kb
**** 用户空间
用户空间malloc通过brk进行分配的内存不立即归还给系统，而是缓存（不足1kb的资源）
**** 内核空间
linux用slab分配器来管理内存，slab可以看做伙伴系统的缓存
## 内存回收
free()与unmap()来防止只生产不释放的内存泄露。
1.回收缓存 LRU
2.回收不常用内存到磁盘，Swap，把磁盘当内存
3.OOM直接杀掉占大内存的进程，oom_score分数，cpu时间与内存大小共同决定

# 性能工具
# free 
第一列，total 是总内存大小；
第二列，used 是已使用内存的大小，包含了共享内存；
第三列，free 是未使用内存的大小；
第四列，shared 是共享内存的大小；
第五列，buff/cache 是缓存和缓冲区的大小；
最后一列，available 是新进程可用内存的大小。

这里尤其注意一下，最后一列的可用内存 available 。available 不仅包含未使用内存，还包括了可回收的缓存，所以一般会比未使用内存更大。不过，并不是所有缓存都可以回收，因为有些缓存可能正在使用中。
# top
VIRT 是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内。
RES 是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括 Swap 和共享内存。
SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。
%MEM 是进程使用物理内存占系统总内存的百分比。

第一，虚拟内存通常并不会全部分配物理内存。从上面的输出，你可以发现每个进程的虚拟内存都比常驻内存大得多。
第二，共享内存 SHR 并不一定是共享的，比方说，程序的代码段、非共享的动态链接库，也都算在 SHR 里。当然，SHR 也包括了进程间真正共享的内存。所以在计算多个进程的内存使用时，不要把所有进程的 SHR 直接相加得出结果。